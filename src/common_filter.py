from __future__ import print_function
import sys
import vcf.filters
import configparser
import os.path


def eprint(*args, **kwargs):
# Portable printing to stderr, from https://stackoverflow.com/questions/5574702/how-to-print-to-stderr-in-python-2
    print(*args, file=sys.stderr, **kwargs)

# Configuration file and initialization of parameters:
# * we can read a configuration file (ini format) as an alternative to passing command line parameters
#   * --config config.ini will read config file config.ini, and read parameters associated with section [ vaf ]
#   * See details here: https://docs.python.org/3/library/configparser.html#supported-ini-file-structure
# * A parameter in configuration file will be overridden by command line argument of the same name
# * No default command line values in general

class ConfigFileFilter(vcf.filters.Base):
    'Base class of pyvcf filters which can read from configuration ini file'

    def set_args(self, config, args, option, required=True, arg_type="string"):
        '''
        Set class attributes directly from command line args (priority) or configparser, if present.
        set_args(self,config,args,"foo") will define self.foo = "foo value"
        arg_type = "float", "int" will cast to float, int.  This should be generalized.
        '''
        value = None
        if option in vars(args) and vars(args)[option] is not None:
            value = vars(args)[option]
            if self.debug:
                eprint("Setting %s = %s from args" % (option, value))
        elif config is not None and config.has_option(self.name, option):
            if arg_type == "float":
                value = config.getfloat(self.name, option)
            elif arg_type == "int":
                value = config.getint(self.name, option)
            elif arg_type == "string":
                value = config.get(self.name, option)
            else:
                raise Exception("Unknown arg_type: %s " % arg_type)
                
            if self.debug:
                eprint("Setting %s = %s from config" % (option, value))

        if value is None:
            msg = "Argument %s not defined" % option
            if required:
                raise Exception("Error: %s " % msg)
            else:
                if self.debug: eprint("Config value %s not defined" % option)
        # set this attribute even if not defined - it will have value of None
        setattr(self, option, value)

# https://docs.python.org/3/library/configparser.html and https://docs.python.org/2/library/configparser.html
    def read_config_file(self, config_fn):
    # return None if not defined

        if config_fn is None:
            return None
        if self.debug:
            eprint("Reading configuration file " + config_fn)
        if not os.path.isfile(config_fn):
            raise Exception("Error: Configuration file %s not found." % config_fn)
        config = configparser.ConfigParser()
        config.read(config_fn)
        return config

class VEPFilter(ConfigFileFilter):
    'Base class of pyvcf filters which can filter on VEP CSQ INFO field'

    def get_CSQ_header(self, vcf_fn):
        '''Parse VCF header to obtain field names associated with VCF CSQ INFO field.  Return array of field headers'''

        # We need to parse description in order to get CSQ header names, and this information is in Reader
        # since pyvcf's vcf_filter.py does not expose vcf.Reader, we need to do the parsing here ourselves.
        # For this reason the vcf filename needs to be passed directly here as --input_vcf.
        vcf_reader = vcf.Reader(open(vcf_fn, 'r'))
        if 'CSQ' not in vcf_reader.infos:
            eprint("CSQ not in infos")
            raise Exception( "CSQ INFO field missing for %s\nThis field is typically generated during VEP annotation" % vcf_fn)

        # Test to see if any records exist.  This isn't really used for anything but may be informative for user
        try:
            r = vcf_reader.next()
        except StopIteration:
            eprint("Note: %s has no VCF records" % vcf_fn)

        CSQ_desc = vcf_reader.infos['CSQ'].desc

        # CSQ description field has the format: "Consequence annotations from Ensembl VEP. Format: Allele|Consequence|...|CLIN_SIG|SOMATIC|PHENO"
        # complain and quit if unexpected format
        leading_CSQ_text = "Consequence annotations from Ensembl VEP. Format:"
        if not CSQ_desc.startswith(leading_CSQ_text):
            raise Exception( "CSQ header has unexpected format in %s" % vcf_fn)
        CSQ_desc = CSQ_desc[len(leading_CSQ_text)+1:]        
        CSQ_headers = CSQ_desc.split('|')
        if not "PICK" in CSQ_headers: 
            raise Exception( "CSQ field PICK not found.  Was this VCF generated by VEP with --flag_pick? ")
        return CSQ_headers


    def parse_CSQ(self, record):
        '''Read CSQ field of VCF and return dictionary of one labeled with PICK.  If only one record, return that one regardless of PICK'''

        if not "CSQ" in record.INFO: 
            raise Exception( "CSQ field not found.  Was this VCF generated by VEP? ")
        if len(record.INFO['CSQ']) == 1:
            pick_first = True
        else:
            pick_first = False

        for CSQ_transcript in record.INFO['CSQ']:
            val = CSQ_transcript.split('|')

            CSQ = dict(zip(self.CSQ_headers, val)) 
            if CSQ["PICK"] == "1" or pick_first: 
                return CSQ
        return None # this is probably an error condition

