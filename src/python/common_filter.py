from __future__ import print_function
import sys
import vcf.filters
import configparser
import os.path


def eprint(*args, **kwargs):
# Portable printing to stderr, from https://stackoverflow.com/questions/5574702/how-to-print-to-stderr-in-python-2
    print(*args, file=sys.stderr, **kwargs)

# Configuration file and initialization of parameters:
# * we can read a configuration file (ini format) as an alternative to passing command line parameters
#   * --config config.ini will read config file config.ini, and read parameters associated with section [ vaf ]
#   * See details here: https://docs.python.org/3/library/configparser.html#supported-ini-file-structure
# * A parameter in configuration file will be overridden by command line argument of the same name
# * No default command line values in general

class ConfigFileFilter(vcf.filters.Base):
    'Base class of pyvcf filters which can read from configuration ini file'

    def set_args(self, config, args, option, required=True, arg_type="string"):
        '''
        Set class attributes directly from command line args (priority) or configparser, if present.
        set_args(self,config,args,"foo") will define self.foo = "foo value"
        arg_type = "float", "int" will cast to float, int.  This should be generalized.
        '''
        value = None
        if option in vars(args) and vars(args)[option] is not None:
            value = vars(args)[option]
            if self.debug:
                eprint("Setting %s = %s from args" % (option, value))
        elif config is not None and config.has_option(self.name, option):
            if arg_type == "float":
                value = config.getfloat(self.name, option)
            elif arg_type == "int":
                value = config.getint(self.name, option)
            elif arg_type == "string":
                value = config.get(self.name, option)
            else:
                raise Exception("Unknown arg_type: %s " % arg_type)
                
            if self.debug:
                eprint("Setting %s = %s from config" % (option, value))

        if value is None:
            msg = "Argument %s not defined" % option
            if required:
                raise Exception("Error: %s " % msg)
            else:
                if self.debug: eprint("Config value %s not defined" % option)
        # set this attribute even if not defined - it will have value of None
        setattr(self, option, value)

# https://docs.python.org/3/library/configparser.html and https://docs.python.org/2/library/configparser.html
    def read_config_file(self, config_fn):
    # return None if not defined

        if config_fn is None:
            return None
        if self.debug:
            eprint("Reading configuration file " + config_fn)
        if not os.path.isfile(config_fn):
            raise Exception("Error: Configuration file %s not found." % config_fn)
        config = configparser.ConfigParser()
        config.read(config_fn)
        return config

class VEPFilter(ConfigFileFilter):
    'Base class of pyvcf filters which can filter on VEP CSQ INFO field'

    @classmethod
    def get_CSQ_header(cls, vcf_fn):
        '''Parse VCF header to obtain field names associated with VCF CSQ INFO field.  Return array of field headers'''

        # We need to parse description in order to get CSQ header names, and this information is in Reader
        # since pyvcf's vcf_filter.py does not expose vcf.Reader, we need to do the parsing here ourselves.
        # For this reason the vcf filename needs to be passed directly here as --input_vcf.
        vcf_reader = vcf.Reader(open(vcf_fn, 'r'))

        if 'CSQ' not in vcf_reader.infos:
            eprint("CSQ not in infos")
            raise Exception( "CSQ INFO field missing for %s\nThis field is typically generated during VEP annotation" % vcf_fn)

        CSQ_desc = vcf_reader.infos['CSQ'].desc

        # CSQ description field has the format: "Consequence annotations from Ensembl VEP. Format: Allele|Consequence|...|CLIN_SIG|SOMATIC|PHENO"
        # complain and quit if unexpected format
        leading_CSQ_text = "Consequence annotations from Ensembl VEP. Format:"
        if not CSQ_desc.startswith(leading_CSQ_text):
            raise Exception( "CSQ header has unexpected format in %s" % vcf_fn)
        CSQ_desc = CSQ_desc[len(leading_CSQ_text)+1:]        
        CSQ_headers = CSQ_desc.split('|')
        if not "PICK" in CSQ_headers: 
            raise Exception( "CSQ field PICK not found.  Was this VCF generated by VEP with --flag_pick? ")
        return CSQ_headers

    @classmethod
    def parse_CSQ(cls, record, CSQ_headers):
        '''Read CSQ field of VCF and return dictionary of one labeled with PICK.  If only one record, return that one regardless of PICK'''

        if not "CSQ" in record.INFO: 
            raise Exception( "CSQ field not found.  Was this VCF generated by VEP? ")
        if len(record.INFO['CSQ']) == 1:
            pick_first = True
        else:
            pick_first = False

        for CSQ_transcript in record.INFO['CSQ']:
            val = CSQ_transcript.split('|')

            CSQ = dict(zip(CSQ_headers, val)) 
            if CSQ["PICK"] == "1" or pick_first: 
                return CSQ
        return None # this is probably an error condition

    # try to guess type of existing variation
    # We use the following heuristic to identify whether variant belongs in various databases:
    # * if existing variation CSQ field begins with "rs", is_dbsnp = true 
    # * if existing variation CSQ field begins with "COSV", is_cosmic = true
    #   * based on examining COSMIC web site for several different examples
    # * if ClinVar CSQ field has non-zero value, is_clinvar = true
    #   * this value corresponds to Variation ID
    # Return tuple (is_dbsnp, is_cosmic, is_clinvar)
    @classmethod
    def get_id_type(cls, CSQ):
        (is_dbsnp, is_cosmic, is_clinvar) = (False, False, False)

        if CSQ["Existing_variation"] != "":
            CSQ_values = CSQ["Existing_variation"].split("&")
            for ev in CSQ_values:
                is_dbsnp = is_dbsnp or ev.startswith("rs")
                is_cosmic = is_cosmic or ev.startswith("COSV")

        if CSQ["ClinVar"]:              
            is_clinvar = True

        return (is_dbsnp, is_cosmic, is_clinvar)


    # get string value to be used as ID for variant.  Based on information from VEP annotation
    # if id_policy is 'dbsnp', ID is just dbsnp ID
    # if it is 'all', use all variants
    #  * all IDs in Existing_variation and ClinVar
    #  * note that this may include variants other than dbSnP, COSMIC, or ClinVar
    # return semicolon separated list of relevant IDs per https://samtools.github.io/hts-specs/VCFv4.2.pdf
    @classmethod
    def get_id_name(cls, CSQ, id_policy):
        id_names = []
        if id_policy not in ["dbsnp", "all"]:
            raise Exception( "Illegal id_policy ")
            
        if CSQ["Existing_variation"] != "":
            CSQ_values = CSQ["Existing_variation"].split("&")
            for ev in CSQ_values:
                if ev.startswith("rs"):
                    id_names.append(ev)
                elif id_policy == "all":
                    id_names.append(ev)
        if id_policy == "all":
            if CSQ["ClinVar"]:              
                id_names.append(CSQ["ClinVar"])
        if id_names == []:
            return "."
        else:
            return ';'.join(id_names)
