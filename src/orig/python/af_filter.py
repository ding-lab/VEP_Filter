from common_filter import *
import sys

# Filter VCF files according to allele frequency as obtained from VEP annotation
# see https://useast.ensembl.org/info/docs/tools/vep/script/vep_options.html#opt_af
# Specifically, reject any variant with AF < max_AF
#
# A number of AF fields can be used, as defined with --af_field.  By default, "MAX_AF" is 
# used, defined as, "Report the highest allele frequency observed in any population from 1000 genomes, ESP or gnomAD"
# Other fields, such as "gnomAD_AF" can also be used.  Note that ExAC is deprecated 
# We rely on VCF to pick the most significant transcript (--flag_pick)
#
# Assuming CSQ field (generated by VEP) exists in input VCF.  Exit with error if not
#
# The following are required
# * --max_af 
# * --af_field 
# * --input_vcf
#
# These may be specified on the command line (e.g., --max_af 0.005) or in
# configuration file, as specified by --config config.ini  Sample contents of config file:
#   [af]
#   af_field = AF_MAX
#
# optional command line parameters
# --debug
# --config config.ini
# --bypass  -- Retain all reads
# --bypass_if_missing - turn bypass mode on if AF_MAX is missing
# --dump
#
# Note that the input_vcf file will in general be specified twice, once as input into vcf_filter.py
# and once as input into this filter directly.
# --bypass_if_missing is designed to keep filter from exiting with error if MAX_AF (or other field as defined by af_field) is
#   missing; this may happen if VEP annotation done with online VEP DB, which doesn't generate AF-related fields.  Note that
#   we still require CSQ field to be present; this is generated by vep_annotate.

class AFFilter(VEPFilter):
    'Filter variant sites by AF fields as provided by VEP annotation'

    name = 'af'

    @classmethod
    def customize_parser(self, parser):
        parser.add_argument('--debug', action="store_true", default=False, help='Print debugging information to stderr')
        parser.add_argument('--bypass', action="store_true", default=False, help='Bypass filter by retaining all variants')
        parser.add_argument('--bypass_if_missing', action="store_true", default=False, help='Bypass filter if "af_field" missing rather than quit with error')
        parser.add_argument('--dump', action="store_true", default=False, help='Dump out CSQ dictionary for each read')
        parser.add_argument('--config', type=str, help='Optional configuration file')
        parser.add_argument('--input_vcf', type=str, help='Input VCF filename', required=True)
        parser.add_argument('--max_af', type=int, help='Retain calls with AF < max_af')
        parser.add_argument('--af_field', type=int, help='VCF variable (INFO CSQ entry) associated with AF to evaluate')

    def __init__(self, args):
        self.CSQ_headers = self.get_CSQ_header(args.input_vcf)

        # These will not be set from config file (though could be)
        self.debug = args.debug
        self.bypass = args.bypass
        self.dump = args.dump

        # Read arguments from config file first, if present.
        # Then read from command line args, if defined
        # Note that default values in command line args would
        #   clobber configuration file values so are not defined
        config = self.read_config_file(args.config)

        self.set_args(config, args, "af_field")
        self.set_args(config, args, "max_af", arg_type="float")

        if self.af_field not in self.CSQ_headers and not self.bypass:
            if not args.bypass_if_missing:
                raise Exception( "CSQ field %s not found in %s" % (self.af_field, args.input_vcf) )
            else:
                eprint( "NOTE: CSQ field %s not found in %s.  Bypassing filter with --bypass_if_missing" % (self.af_field, args.input_vcf) )
                self.bypass = True

        # below becomes Description field in VCF
        if self.bypass:
            self.__doc__ = "Bypassing AF filter, retaining all reads"
        else:
            self.__doc__ = "Retain calls where %s < %f " % (self.af_field, self.max_af)

    def filter_name(self):
        return self.name

    def __call__(self, record):

        if self.bypass:
            if (self.debug): eprint("** Bypassing %s filter, retaining read **" % self.name )
            return

        # CSQ has all VCF CSQ INFO entries as dictionary
        CSQ = self.parse_CSQ(record)
        if self.dump:
            eprint("CSQ: " + str(CSQ) )

        if CSQ[self.af_field]:
            af = float(CSQ[self.af_field])
        else:
            af = None

        # Pass if empty
        if af is None:
            if self.debug: eprint("** PASS (%s is undefined) **" % (self.af_field))
            return

        # Reject if af >= max_af
        if af >= self.max_af:
            if self.debug: eprint("** FAIL %s = %f ** " % (self.af_field, af))
            return "%s: %d" % (self.af_field, af)

        if self.debug:
            eprint("** PASS (%s = %f) **" % (self.af_field, af))

